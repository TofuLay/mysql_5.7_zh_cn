# 14.5.1 Buffer Pool

Buffer Pool是主存中存储被访问过的表数据和索引数据的区域。Buffer Pool允许频繁使用的数据直接在内存当中处理，加快了处理速度；在专用的服务器上，将Buffer Pool占用物理内存的80%。

为了提高大容量读取操作的效率，Buffer Pool被分成可以容纳多行的[pages](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page) 。为了提高缓存管理的效率，Buffer Pool被实现为链接的[pages](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page)  list;使用LRU算法的变体算法，很少使用的数据在缓存中T出。

了解如何利用缓冲池将频繁访问的数据保存在内存中是MySQL调优的一个重要方面。

### **Buffer Pool LRU Algorithm**

Buffer Pool 是实际上是一个list，通过LRU算法进行管理该list，当buffer pool中的空间来添加新页时，最近最少使用的页面被逐出，新页添加到list的中间位置，此midpoint插入策略将列表视为两个子列表：

* 在头部，最近访问过的新（“young”）页面的子列表
* 在尾部，是最近访问的旧页面的子列表

**图示 14.2 Buffer Pool List**

![](../../.gitbook/assets/image%20%281%29.png)

该算法保留新子列表中查询大量使用的页面.旧子列表包含较少使用的页面;这些页面是待逐出的页面：

默认的，算法是按照下面来进行操作：

* buffer pool的3/8用于old list
* midpoint在新子列表的尾部与旧子列表的头部相交的边界。
* 当InnoDB将页面读入缓冲池时，它最初将其插入中点（旧子列表的头部）。可以读取页面，因为它是用户指定的操作（如SQL查询）所必需的，或者是InnoDB自动执行的预读操作的一部分。
* 访问旧子列表中的页面使其“young”，将其移动到缓冲池的头部（新子列表的头部）。如果因为需要而读取页面，则会立即进行第一次访问，并使页面变得年轻。如果由于预读而读取了页面，则第一次访问不会立即发生（并且在页面被逐出之前可能根本不会发生）。
* 当数据库运行时，缓冲池中的页面通过移动到列表尾部而不会被“访问”。新旧子列表中的页面随着其他页面的变化而变旧。旧子列表中的页面也会随着页面插入中点而老化。最终，仍然未使用的页面到达旧子列表的尾部并被逐出。

默认情况下，查询读取的页面会立即移动到新的子列表中，这意味着它们会更长时间地保留在缓冲池中。表扫描（例如为mysqldump操作执行，或者没有WHERE子句的SELECT语句）可以将大量数据带入缓冲池并驱逐等量的旧数据，即使新数据从未再次使用过。类似地，由预读后台线程加载然后仅访问一次的页面移动到新列表的头部。这些情况可以将经常使用的页面推送到旧的子列表中，在那里它们会被驱逐。有关优化此行为的信息，请参见第14.8.3.3节“使缓冲池扫描阻止”和第14.8.3.4节“配置InnoDB缓冲池预取（预读）”。

InnoDB标准监视器输出包含BUFFER POOL和MEMORY部分中有关缓冲池LRU算法操作的几个字段。有关详细信息，请参阅使用InnoDB标准监视器监视缓冲池。

### **Buffer Pool Configuration**

通过设置Buffer Pool的配置项目来改进性能：

* 理想的情况下，buffer pool的空间调的越大越好，只要给服务器上其他的进程留出足够的空间；buffer pool 越大，InnoDB 越像一个内存数据库，只要从磁盘中读取一次，在随后的读取中只需要从内存读取就可以了，查看[Section 14.8.3.1, “Configuring InnoDB Buffer Pool Size”](https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html)
* 在有足够内存的64位系统上，可以将buffer pool 分成多个pool，减少并发操作对内存的争用，详情请看[Section 14.8.3.2, “Configuring Multiple Buffer Pool Instances”](https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html).
* 可以将频繁访问的数据保留在内存中，不管突然的操作峰值是否会将大量不经常访问的数据写入buffer pool中， [Section 14.8.3.3, “Making the Buffer Pool Scan Resistant”](https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html).
* 
